= Recharge Community Pool

If the user does not have funds in the Community Pool, IMA will freeze the user from exits until the user's pool has sufficient balance to fund the exit process.

The **CommunityPool** contract is on Rinkeby. Check out the https://github.com/skalenetwork/skale-network/tree/master/releases/rinkeby/IMA[current release page] for ABIs.

[tabs]
====
Javascript::
+
--
[source,javascript]
----
const Web3 = require("web3");
const Tx = require("ethereumjs-tx").Transaction;

const communityPoolAddress = rinkebyABIs.community_pool_address;
const communityPoolABI = rinkebyABIs.community_pool_abi;

const web3 = new Web3(rinkeby);

let CommunityPool = new web3.eth.Contract(
  communityPoolABI,
  communityPoolAddress
);

let registerMainnetCommunityPool = CommunityPool.methods
    .rechargeUserWallet(schainName)
    .encodeABI();

web3.eth.getTransactionCount(accountForMainnet).then((nonce) => {
  //create raw transaction
  const rawRechargeUserWallet = {
    chainId: chainId,
    from: accountForMainnet,
    nonce: "0x" + nonce.toString(16),
    data: registerMainnetCommunityPool,
    to: communityPoolAddress,
    gas: 6500000,
    gasPrice: 1000000000,
    value: web3.utils.toHex(web3.utils.toWei("0.5", "ether")) // Recharge pool with 0.5 ETH
  };

const txRechargeUserWallet = new Tx(rawRechargeUserWallet, {
      chain: "rinkeby",
      hardfork: "petersburg"
    });
    txRechargeUserWallet.sign(privateKey);

//serialize transaction
const serializedRechargeUserWallet = txRechargeUserWallet.serialize();

//send signed transaction
web3.eth
  .sendSignedTransaction(
    "0x" + serializedRechargeUserWallet.toString("hex")
  )
  .on("receipt", (receipt) => {
    //record receipt to console
    console.log(receipt);
  })
  .catch(console.error);
});
----
--
====

== Exit Reimbursement Flow Process

The exit flow through IMA is conducted as follows:

[plantuml]
....
@startuml

User -> CommunityPool: rechargeUserWallet(schainName)
User -> TokenManager: exitToMain()
TokenManager -> CommunityLocker: checkAllowedToSendMessage()
CommunityLocker --> CommunityLocker: registeredTokenManager?
CommunityLocker --> CommunityLocker: receiverIsActive?
CommunityLocker --> CommunityLocker: exitMessageRate?
TokenManager --> TokenManager: burn()
TokenManager -> MessageProxySchain: postOutgoingMessage()

MessageProxySchain --> NodeIMAAgent: newMessageEvent
Node -> TransactionManager: exit + gasEstimate
TransactionManager -> MessageProxyMainnet: postIncomingMessage()

alt sufficient CommunityPool Funds

  MessageProxyMainnet -> CommunityPool: refundGasByUser()
  CommunityPool -> Node: sendValue()

else insufficient CommunityPool Funds

  MessageProxyMainnet -> CommunityPool: refundGasByUser()

  CommunityPool -> MessageProxySchain: postMessage(lockUser)
  MessageProxyMainnet -> CommunityPool:  refundGasBySchainWallet()
  CommunityPool -> Wallets: refundGasBySchain()
  Wallets -> Node: sendValue()
  MessageProxySchain -> CommunityLocker: emit LockUser()


end

@enduml
....


=== Description

.Using gasPayer() implementing contracts
. User must first fund CommunityPool.
. User executes exitToMain().
. TokenManager then checks Community Locker whether exit conditions are met.
. TokenManager then burns the token(s) and posts an outgoing message via MessageProxy for Schain.
. MessageProxy for Schain posts a new event which is found by 1 out of 16 SKALE Chain nodes running IMA agent.
. The selected node's agent prepares the transaction and estimates the gas required
. Agent sends the transaction via transaction-manager through MessageProxy for Mainnet, and the node wallet funds the transaction.
. MessageProxy for Mainnet then requests CommmunityPool to refund the node.
. CommunityPool sends funds to the node.
. If CommunityPool has insufficient user's funds, then CommunityPool posts a LockUser request to CommunityLocker, and refund is requested by the SKALE Chain self-recharging wallet.  In this case, the self-recharging wallet sends funds to the node wallet and the user is Locked via the CommunityLocker.
